apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: ingresstlshost
spec:
  crd:
    spec:
      names:
        kind: IngressTLSHost
      validation:
        legacySchema: false
        openAPIV3Schema:
          type: object
          properties:
            allowedHostPatterns:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package admission.ingresstlshost

        violation[{"msg": msg, "details": {"resource": "Ingress", "path": rule_info.path, "host": host}}] {
          not waiver_exempts
          input.review.kind.kind == "Ingress"
          rule_info := ingress_rules[_]
          host := rule_info.host
          not valid_host(host)
          msg := sprintf("Ingress host must be specified and match allowed patterns. resource=Ingress host=%q path=%s", [host, rule_info.path])
        }

        violation[{"msg": msg, "details": {"resource": "Ingress", "path": rule_info.path, "host": host}}] {
          not waiver_exempts
          input.review.kind.kind == "Ingress"
          rule_info := ingress_rules[_]
          host := rule_info.host
          valid_host(host)
          not tls_covers_host(host)
          msg := sprintf("Ingress TLS must cover rule host. resource=Ingress host=%q path=%s", [host, rule_info.path])
        }

        ingress_rules[{"host": host, "path": path}] {
          spec := input.review.object.spec
          rule := spec.rules[_]
          host := object.get(rule, "host", "")
          path := sprintf("spec.rules[*].host")
        }

        valid_host(host) {
          host != ""
          not is_wildcard(host)
        }

        valid_host(host) {
          host != ""
          is_wildcard(host)
          pattern_allowed(host)
        }

        is_wildcard(host) {
          contains(host, "*")
        }

        pattern_allowed(host) {
          params := object.get(input, "parameters", {})
          patterns := object.get(params, "allowedHostPatterns", [])
          pattern := patterns[_]
          re_match(pattern, host)
        }

        tls_covers_host(host) {
          spec := input.review.object.spec
          tls := object.get(spec, "tls", [])
          entry := tls[_]
          hosts := object.get(entry, "hosts", [])
          hosts[_] == host
        }

        violation[entry] {
          entry := waiver_violations[_]
        }

        waiver_violations[{"msg": msg, "details": {"resource": input.review.kind.kind, "path": path}}] {
          waiver_enabled
          waiver_reason_missing
          reason_key := waiver_reason_key
          reason_key != ""
          path := sprintf("metadata.annotations[%q]", [reason_key])
          msg := sprintf("Waiver reason annotation %q must be provided whenever %q is set. resource=%s path=%s", [reason_key, waiver_expiry_key, input.review.kind.kind, path])
        }

        waiver_violations[{"msg": msg, "details": {"resource": input.review.kind.kind, "path": path}}] {
          waiver_enabled
          waiver_expiry_parse_error
          path := sprintf("metadata.annotations[%q]", [waiver_expiry_key])
          msg := sprintf("Waiver expiry annotation %q must use YYYY-MM-DD or RFC3339 format. resource=%s path=%s", [waiver_expiry_key, input.review.kind.kind, path])
        }

        waiver_violations[{"msg": msg, "details": {"resource": input.review.kind.kind, "path": path}}] {
          waiver_enabled
          waiver_expired
          waiver_expiry_value(value)
          path := sprintf("metadata.annotations[%q]", [waiver_expiry_key])
          msg := sprintf("Waiver expired on %s; policy enforcement has resumed. resource=%s path=%s", [value, input.review.kind.kind, path])
        }

        waiver_exempts {
          waiver_enabled
          waiver_requested
          waiver_reason_present
          waiver_expiry_ts(ts)
          ts >= time.now_ns()
        }

        waiver_reason_present {
          reason_key := waiver_reason_key
          reason_key == ""
        }

        waiver_reason_present {
          reason_key := waiver_reason_key
          reason_key != ""
          annotations := waiver_annotations
          val := trim_space(object.get(annotations, reason_key, ""))
          val != ""
        }

        waiver_reason_missing {
          waiver_requested
          reason_key := waiver_reason_key
          reason_key != ""
          annotations := waiver_annotations
          val := trim_space(object.get(annotations, reason_key, ""))
          val == ""
        }

        waiver_expiry_parse_error {
          waiver_requested
          waiver_expiry_value(value)
          not parse_waiver_expiry(value, _)
        }

        waiver_expired {
          waiver_expiry_ts(ts)
          ts < time.now_ns()
        }

        waiver_expiry_ts(ts) {
          waiver_expiry_value(value)
          parse_waiver_expiry(value, ts)
        }

        parse_waiver_expiry(value, ts) {
          re_match(`^\d{4}-\d{2}-\d{2}$`, value)
          ts := time.parse_rfc3339_ns(sprintf("%sT23:59:59Z", [value]))
        }

        parse_waiver_expiry(value, ts) {
          re_match(`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z$`, value)
          ts := time.parse_rfc3339_ns(value)
        }

        parse_waiver_expiry(value, ts) {
          re_match(`^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}[+-]\d{2}:\d{2}$`, value)
          ts := time.parse_rfc3339_ns(value)
        }

        waiver_expiry_value(value) {
          waiver_requested
          annotations := waiver_annotations
          key := waiver_expiry_key
          raw := object.get(annotations, key, "")
          value := trim_space(raw)
        }

        waiver_requested {
          waiver_enabled
          annotations := waiver_annotations
          key := waiver_expiry_key
          val := trim_space(object.get(annotations, key, ""))
          val != ""
        }

        waiver_annotations = annotations {
          metadata := object.get(input.review.object, "metadata", {})
          annotations := object.get(metadata, "annotations", {})
        }

        waiver_enabled {
          waiver_expiry_key != ""
        }

        waiver_config = object.get(object.get(input, "parameters", {}), "waiver", {})

        waiver_expiry_key = key {
          key := object.get(waiver_config, "expiryAnnotation", "")
        }

        waiver_reason_key = key {
          key := object.get(waiver_config, "reasonAnnotation", "")
        }

        trim_space(val) = trimmed {
          trimmed := trim(val, " \t\r\n")
        }
